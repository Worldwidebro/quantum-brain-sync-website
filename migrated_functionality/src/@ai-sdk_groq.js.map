{
  "version": 3,
  "sources": ["../../@ai-sdk/groq/src/groq-provider.ts", "../../@ai-sdk/groq/src/groq-chat-language-model.ts", "../../@ai-sdk/groq/src/convert-to-groq-chat-messages.ts", "../../@ai-sdk/groq/src/get-response-metadata.ts", "../../@ai-sdk/groq/src/groq-error.ts", "../../@ai-sdk/groq/src/groq-prepare-tools.ts", "../../@ai-sdk/groq/src/map-groq-finish-reason.ts", "../../@ai-sdk/groq/src/groq-transcription-model.ts"],
  "sourcesContent": ["import {\n  LanguageModelV1,\n  NoSuchModelError,\n  ProviderV1,\n  TranscriptionModelV1,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  loadApiKey,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { GroqChatLanguageModel } from './groq-chat-language-model';\nimport { GroqChatModelId, GroqChatSettings } from './groq-chat-settings';\nimport { GroqTranscriptionModelId } from './groq-transcription-settings';\nimport { GroqTranscriptionModel } from './groq-transcription-model';\n\nexport interface GroqProvider extends ProviderV1 {\n  /**\nCreates a model for text generation.\n*/\n  (modelId: GroqChatModelId, settings?: GroqChatSettings): LanguageModelV1;\n\n  /**\nCreates an Groq chat model for text generation.\n   */\n  languageModel(\n    modelId: GroqChatModelId,\n    settings?: GroqChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates a model for transcription.\n   */\n  transcription(modelId: GroqTranscriptionModelId): TranscriptionModelV1;\n}\n\nexport interface GroqProviderSettings {\n  /**\nBase URL for the Groq API calls.\n     */\n  baseURL?: string;\n\n  /**\nAPI key for authenticating requests.\n     */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n}\n\n/**\nCreate an Groq provider instance.\n */\nexport function createGroq(options: GroqProviderSettings = {}): GroqProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.groq.com/openai/v1';\n\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'GROQ_API_KEY',\n      description: 'Groq',\n    })}`,\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: GroqChatModelId,\n    settings: GroqChatSettings = {},\n  ) =>\n    new GroqChatLanguageModel(modelId, settings, {\n      provider: 'groq.chat',\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createLanguageModel = (\n    modelId: GroqChatModelId,\n    settings?: GroqChatSettings,\n  ) => {\n    if (new.target) {\n      throw new Error(\n        'The Groq model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId, settings);\n  };\n\n  const createTranscriptionModel = (modelId: GroqTranscriptionModelId) => {\n    return new GroqTranscriptionModel(modelId, {\n      provider: 'groq.transcription',\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n  };\n\n  const provider = function (\n    modelId: GroqChatModelId,\n    settings?: GroqChatSettings,\n  ) {\n    return createLanguageModel(modelId, settings);\n  };\n\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.textEmbeddingModel = (modelId: string) => {\n    throw new NoSuchModelError({ modelId, modelType: 'textEmbeddingModel' });\n  };\n  provider.transcription = createTranscriptionModel;\n\n  return provider;\n}\n\n/**\nDefault Groq provider instance.\n */\nexport const groq = createGroq();\n", "import {\n  InvalidResponseDataError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1ProviderMetadata,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  isParsableJson,\n  parseProviderOptions,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToGroqChatMessages } from './convert-to-groq-chat-messages';\nimport { getResponseMetadata } from './get-response-metadata';\nimport { GroqChatModelId, GroqChatSettings } from './groq-chat-settings';\nimport { groqErrorDataSchema, groqFailedResponseHandler } from './groq-error';\nimport { prepareTools } from './groq-prepare-tools';\nimport { mapGroqFinishReason } from './map-groq-finish-reason';\n\ntype GroqChatConfig = {\n  provider: string;\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class GroqChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  readonly supportsStructuredOutputs = false;\n  readonly defaultObjectGenerationMode = 'json';\n\n  readonly modelId: GroqChatModelId;\n  readonly settings: GroqChatSettings;\n\n  private readonly config: GroqChatConfig;\n\n  constructor(\n    modelId: GroqChatModelId,\n    settings: GroqChatSettings,\n    config: GroqChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get supportsImageUrls(): boolean {\n    // image urls can be sent if downloadImages is disabled (default):\n    return !this.settings.downloadImages;\n  }\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    stream,\n    providerMetadata,\n  }: Parameters<LanguageModelV1['doGenerate']>[0] & {\n    stream: boolean;\n  }) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (\n      responseFormat != null &&\n      responseFormat.type === 'json' &&\n      responseFormat.schema != null\n    ) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details: 'JSON response format schema is not supported',\n      });\n    }\n\n    const groqOptions = parseProviderOptions({\n      provider: 'groq',\n      providerOptions: providerMetadata,\n      schema: z.object({\n        reasoningFormat: z.enum(['parsed', 'raw', 'hidden']).nullish(),\n      }),\n    });\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      stop: stopSequences,\n      seed,\n\n      // response format:\n      response_format:\n        // json object response format is not supported for streaming:\n        stream === false && responseFormat?.type === 'json'\n          ? { type: 'json_object' }\n          : undefined,\n\n      // provider options:\n      reasoning_format: groqOptions?.reasoningFormat,\n\n      // messages:\n      messages: convertToGroqChatMessages(prompt),\n    };\n\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, toolWarnings } = prepareTools({ mode });\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            response_format:\n              // json object response format is not supported for streaming:\n              stream === false ? { type: 'json_object' } : undefined,\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: {\n            ...baseArgs,\n            tool_choice: {\n              type: 'function',\n              function: { name: mode.tool.name },\n            },\n            tools: [\n              {\n                type: 'function',\n                function: {\n                  name: mode.tool.name,\n                  description: mode.tool.description,\n                  parameters: mode.tool.parameters,\n                },\n              },\n            ],\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args, warnings } = this.getArgs({ ...options, stream: false });\n\n    const body = JSON.stringify(args);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: groqFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        groqChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n\n    return {\n      text: choice.message.content ?? undefined,\n      reasoning: choice.message.reasoning ?? undefined,\n      toolCalls: choice.message.tool_calls?.map(toolCall => ({\n        toolCallType: 'function',\n        toolCallId: toolCall.id ?? generateId(),\n        toolName: toolCall.function.name,\n        args: toolCall.function.arguments!,\n      })),\n      finishReason: mapGroqFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: response.usage?.prompt_tokens ?? NaN,\n        completionTokens: response.usage?.completion_tokens ?? NaN,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(response),\n      warnings,\n      request: { body },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args, warnings } = this.getArgs({ ...options, stream: true });\n\n    const body = JSON.stringify({ ...args, stream: true });\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true,\n      },\n      failedResponseHandler: groqFailedResponseHandler,\n      successfulResponseHandler:\n        createEventSourceResponseHandler(groqChatChunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    const toolCalls: Array<{\n      id: string;\n      type: 'function';\n      function: {\n        name: string;\n        arguments: string;\n      };\n      hasFinished: boolean;\n    }> = [];\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: {\n      promptTokens: number | undefined;\n      completionTokens: number | undefined;\n    } = {\n      promptTokens: undefined,\n      completionTokens: undefined,\n    };\n    let isFirstChunk = true;\n\n    let providerMetadata: LanguageModelV1ProviderMetadata | undefined;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof groqChatChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.x_groq?.usage != null) {\n              usage = {\n                promptTokens: value.x_groq.usage.prompt_tokens ?? undefined,\n                completionTokens:\n                  value.x_groq.usage.completion_tokens ?? undefined,\n              };\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapGroqFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.delta == null) {\n              return;\n            }\n\n            const delta = choice.delta;\n\n            if (delta.reasoning != null && delta.reasoning.length > 0) {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: delta.reasoning,\n              });\n            }\n\n            if (delta.content != null && delta.content.length > 0) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: delta.content,\n              });\n            }\n\n            if (delta.tool_calls != null) {\n              for (const toolCallDelta of delta.tool_calls) {\n                const index = toolCallDelta.index;\n\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== 'function') {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`,\n                    });\n                  }\n\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`,\n                    });\n                  }\n\n                  if (toolCallDelta.function?.name == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`,\n                    });\n                  }\n\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: 'function',\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: toolCallDelta.function.arguments ?? '',\n                    },\n                    hasFinished: false,\n                  };\n\n                  const toolCall = toolCalls[index];\n\n                  if (\n                    toolCall.function?.name != null &&\n                    toolCall.function?.arguments != null\n                  ) {\n                    // send delta if the argument text has already started:\n                    if (toolCall.function.arguments.length > 0) {\n                      controller.enqueue({\n                        type: 'tool-call-delta',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id,\n                        toolName: toolCall.function.name,\n                        argsTextDelta: toolCall.function.arguments,\n                      });\n                    }\n\n                    // check if tool call is complete\n                    // (some providers send the full tool call in one chunk):\n                    if (isParsableJson(toolCall.function.arguments)) {\n                      controller.enqueue({\n                        type: 'tool-call',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id ?? generateId(),\n                        toolName: toolCall.function.name,\n                        args: toolCall.function.arguments,\n                      });\n                      toolCall.hasFinished = true;\n                    }\n                  }\n\n                  continue;\n                }\n\n                // existing tool call, merge if not finished\n                const toolCall = toolCalls[index];\n\n                if (toolCall.hasFinished) {\n                  continue;\n                }\n\n                if (toolCallDelta.function?.arguments != null) {\n                  toolCall.function!.arguments +=\n                    toolCallDelta.function?.arguments ?? '';\n                }\n\n                // send delta\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: toolCallDelta.function.arguments ?? '',\n                });\n\n                // check if tool call is complete\n                if (\n                  toolCall.function?.name != null &&\n                  toolCall.function?.arguments != null &&\n                  isParsableJson(toolCall.function.arguments)\n                ) {\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallType: 'function',\n                    toolCallId: toolCall.id ?? generateId(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments,\n                  });\n                  toolCall.hasFinished = true;\n                }\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage: {\n                promptTokens: usage.promptTokens ?? NaN,\n                completionTokens: usage.completionTokens ?? NaN,\n              },\n              ...(providerMetadata != null ? { providerMetadata } : {}),\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body },\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst groqChatResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      message: z.object({\n        content: z.string().nullish(),\n        reasoning: z.string().nullish(),\n        tool_calls: z\n          .array(\n            z.object({\n              id: z.string().nullish(),\n              type: z.literal('function'),\n              function: z.object({\n                name: z.string(),\n                arguments: z.string(),\n              }),\n            }),\n          )\n          .nullish(),\n      }),\n      index: z.number(),\n      finish_reason: z.string().nullish(),\n    }),\n  ),\n  usage: z\n    .object({\n      prompt_tokens: z.number().nullish(),\n      completion_tokens: z.number().nullish(),\n    })\n    .nullish(),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst groqChatChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        delta: z\n          .object({\n            content: z.string().nullish(),\n            reasoning: z.string().nullish(),\n            tool_calls: z\n              .array(\n                z.object({\n                  index: z.number(),\n                  id: z.string().nullish(),\n                  type: z.literal('function').optional(),\n                  function: z.object({\n                    name: z.string().nullish(),\n                    arguments: z.string().nullish(),\n                  }),\n                }),\n              )\n              .nullish(),\n          })\n          .nullish(),\n        finish_reason: z.string().nullable().optional(),\n        index: z.number(),\n      }),\n    ),\n    x_groq: z\n      .object({\n        usage: z\n          .object({\n            prompt_tokens: z.number().nullish(),\n            completion_tokens: z.number().nullish(),\n          })\n          .nullish(),\n      })\n      .nullish(),\n  }),\n  groqErrorDataSchema,\n]);\n", "import {\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { GroqChatPrompt } from './groq-api-types';\n\nexport function convertToGroqChatMessages(\n  prompt: LanguageModelV1Prompt,\n): GroqChatPrompt {\n  const messages: GroqChatPrompt = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        messages.push({ role: 'system', content });\n        break;\n      }\n\n      case 'user': {\n        if (content.length === 1 && content[0].type === 'text') {\n          messages.push({ role: 'user', content: content[0].text });\n          break;\n        }\n\n        messages.push({\n          role: 'user',\n          content: content.map(part => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'image_url',\n                  image_url: {\n                    url:\n                      part.image instanceof URL\n                        ? part.image.toString()\n                        : `data:${\n                            part.mimeType ?? 'image/jpeg'\n                          };base64,${convertUint8ArrayToBase64(part.image)}`,\n                  },\n                };\n              }\n              case 'file': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'File content parts in user messages',\n                });\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args),\n                },\n              });\n              break;\n            }\n          }\n        }\n\n        messages.push({\n          role: 'assistant',\n          content: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n        });\n\n        break;\n      }\n\n      case 'tool': {\n        for (const toolResponse of content) {\n          messages.push({\n            role: 'tool',\n            tool_call_id: toolResponse.toolCallId,\n            content: JSON.stringify(toolResponse.result),\n          });\n        }\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return messages;\n}\n", "export function getResponseMetadata({\n  id,\n  model,\n  created,\n}: {\n  id?: string | undefined | null;\n  created?: number | undefined | null;\n  model?: string | undefined | null;\n}) {\n  return {\n    id: id ?? undefined,\n    modelId: model ?? undefined,\n    timestamp: created != null ? new Date(created * 1000) : undefined,\n  };\n}\n", "import { z } from 'zod';\nimport { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\n\nexport const groqErrorDataSchema = z.object({\n  error: z.object({\n    message: z.string(),\n    type: z.string(),\n  }),\n});\n\nexport type GroqErrorData = z.infer<typeof groqErrorDataSchema>;\n\nexport const groqFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: groqErrorDataSchema,\n  errorToMessage: data => data.error.message,\n});\n", "import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function prepareTools({\n  mode,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n}): {\n  tools:\n    | undefined\n    | Array<{\n        type: 'function';\n        function: {\n          name: string;\n          description: string | undefined;\n          parameters: unknown;\n        };\n      }>;\n  tool_choice:\n    | { type: 'function'; function: { name: string } }\n    | 'auto'\n    | 'none'\n    | 'required'\n    | undefined;\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  const groqTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: unknown;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      groqTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n        },\n      });\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: groqTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: groqTools, tool_choice: type, toolWarnings };\n    case 'tool':\n      return {\n        tools: groqTools,\n        tool_choice: {\n          type: 'function',\n          function: {\n            name: toolChoice.toolName,\n          },\n        },\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n", "import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapGroqFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    case 'function_call':\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'unknown';\n  }\n}\n", "import {\n  TranscriptionModelV1,\n  TranscriptionModelV1CallWarning,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  convertBase64ToUint8Array,\n  createJsonResponseHandler,\n  parseProviderOptions,\n  postFormDataToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { GroqConfig } from './groq-config';\nimport { groqFailedResponseHandler } from './groq-error';\nimport { GroqTranscriptionModelId } from './groq-transcription-settings';\nimport { GroqTranscriptionAPITypes } from './groq-api-types';\n\n// https://console.groq.com/docs/speech-to-text\nconst groqProviderOptionsSchema = z.object({\n  language: z.string().nullish(),\n  prompt: z.string().nullish(),\n  responseFormat: z.string().nullish(),\n  temperature: z.number().min(0).max(1).nullish(),\n  timestampGranularities: z.array(z.string()).nullish(),\n});\n\nexport type GroqTranscriptionCallOptions = z.infer<\n  typeof groqProviderOptionsSchema\n>;\n\ninterface GroqTranscriptionModelConfig extends GroqConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class GroqTranscriptionModel implements TranscriptionModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: GroqTranscriptionModelId,\n    private readonly config: GroqTranscriptionModelConfig,\n  ) {}\n\n  private getArgs({\n    audio,\n    mediaType,\n    providerOptions,\n  }: Parameters<TranscriptionModelV1['doGenerate']>[0]) {\n    const warnings: TranscriptionModelV1CallWarning[] = [];\n\n    // Parse provider options\n    const groqOptions = parseProviderOptions({\n      provider: 'groq',\n      providerOptions,\n      schema: groqProviderOptionsSchema,\n    });\n\n    // Create form data with base fields\n    const formData = new FormData();\n    const blob =\n      audio instanceof Uint8Array\n        ? new Blob([audio])\n        : new Blob([convertBase64ToUint8Array(audio)]);\n\n    formData.append('model', this.modelId);\n    formData.append('file', new File([blob], 'audio', { type: mediaType }));\n\n    // Add provider-specific options\n    if (groqOptions) {\n      const transcriptionModelOptions: Omit<\n        GroqTranscriptionAPITypes,\n        'model'\n      > = {\n        language: groqOptions.language ?? undefined,\n        prompt: groqOptions.prompt ?? undefined,\n        response_format: groqOptions.responseFormat ?? undefined,\n        temperature: groqOptions.temperature ?? undefined,\n        timestamp_granularities:\n          groqOptions.timestampGranularities ?? undefined,\n      };\n\n      for (const key in transcriptionModelOptions) {\n        const value =\n          transcriptionModelOptions[\n            key as keyof Omit<GroqTranscriptionAPITypes, 'model'>\n          ];\n        if (value !== undefined) {\n          formData.append(key, String(value));\n        }\n      }\n    }\n\n    return {\n      formData,\n      warnings,\n    };\n  }\n\n  async doGenerate(\n    options: Parameters<TranscriptionModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<TranscriptionModelV1['doGenerate']>>> {\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { formData, warnings } = this.getArgs(options);\n\n    const {\n      value: response,\n      responseHeaders,\n      rawValue: rawResponse,\n    } = await postFormDataToApi({\n      url: this.config.url({\n        path: '/audio/transcriptions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      formData,\n      failedResponseHandler: groqFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        groqTranscriptionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      text: response.text,\n      segments:\n        response.segments?.map(segment => ({\n          text: segment.text,\n          startSecond: segment.start,\n          endSecond: segment.end,\n        })) ?? [],\n      language: response.language,\n      durationInSeconds: response.duration,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n    };\n  }\n}\n\nconst groqTranscriptionResponseSchema = z.object({\n  task: z.string(),\n  language: z.string(),\n  duration: z.number(),\n  text: z.string(),\n  segments: z.array(\n    z.object({\n      id: z.number(),\n      seek: z.number(),\n      start: z.number(),\n      end: z.number(),\n      text: z.string(),\n      tokens: z.array(z.number()),\n      temperature: z.number(),\n      avg_logprob: z.number(),\n      compression_ratio: z.number(),\n      no_speech_prob: z.number(),\n    }),\n  ),\n  x_groq: z.object({\n    id: z.string(),\n  }),\n});\n"],
  "mappings": "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",
  "names": ["UnsupportedFunctionalityError", "z", "_a", "toolCall", "parseProviderOptions", "combineHeaders", "createJsonResponseHandler"]
}
